# 優先佇列(Priority Queues)
- 在佇列的 **FIFO** 規則裡加上 **優先級** 的比較，依 **時間軸** 存取順序 (進Block box) 再依 **優先級** 取出--刪除順序 (本質上像是排序)

以排序實現PQ : info  --> pqInsert() -->  [sorting Algorithm]  --> pqDelete() -->  排序 

|sorting Algorithm |stable/unstable | worst case | average case  | best case |
|:-----------:|:-------------:|:-----:|:-----------:|:-------------:|
| Selection sort   | unstable | n<sup>2</sup> | n<sup>2</sup> | n<sup>2</sup> |
| Bubble sort      | stable   | n<sup>2</sup> | n<sup>2</sup> | n             |
| Insertion sort   | stable   | n<sup>2</sup> | n<sup>2</sup> | n             |
| Mergesort        | stable   | n * logn      | n * logn      | n * logn      |
| Quicksort        | unstable | n<sup>2</sup> | n * logn      | n * logn      |
| Radixsort        | stable   | n             | n             | n             |
| Tree sort        | unstable | n * logn      | n * logn      | logn          |
| Heap sort        | stable   | n * logn      | n * logn      | n * logn      |

# Heap

info --> 插入:O(logn) -->  [max/min-heap] --> 取出:O(1) -->  Complete Binary Tree/Balance Binary Tree\
不是實際上去做排序，但是可以滿足取出最大值/最小值 (max-heap/min-heap) 的資料結構 
- 適合用陣列來做，以二元樹呈現是 **平衡樹/完全樹**
- <ins> 保證max/min在 **root** 的位置 </ins>，其他不保證
- 每條從 root 延伸出來的枝 (路徑) 一定是<ins>相對排序過 </ins> 

## Build heap
架構
```cpp==
template <class ItemType>
struct HeapType
{ void ReHeapDown(int, int); //新增node
  void ReHeapUp(int, int);   //刪除node
  ItemType * element;
  int numElements;  //heap element
};
```
### **ReHeapUp** //新增node
- 依照完全樹 (Complete Binary Tree) 的結構新的節點加入樹的最底層的最右邊，再以 **bubble sort** 的方式向上比較做排序




### **ReHeapDown** //刪除node \
一. 取出樹根
- 為了維持完全樹的的結構，刪除 node 時，只做內容的更動，盡量不去更動位置。
- 將要刪除的 node 與 bottom (樹最底層最右邊)對調並移除再重新維持heap的結構並更新 bottom
- 註: 先比較左右分支大小再進行排序，總的來說仍是走root的單邊子樹。

二.取出非樹根的 node 
- 同樣是先交換後進行維持 heap 的結構，但多了向上比較且依照 bottom 的位置，可能會做不只 root 單邊子樹的比較。















