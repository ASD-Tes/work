# 優先佇列(Priority Queues)
- 在佇列的 **FIFO** 規則裡加上 **優先級** 的比較，依 **時間軸** 存取順序 (進Block box) 再依 **優先級** 取出--刪除順序 (本質上像是排序)

以排序實現PQ : info  --> pqInsert() -->  [sorting Algorithm]  --> pqDelete() -->  排序 

|sorting Algorithm |stable/unstable | worst case | average case  | best case |
|:-----------:|:-------------:|:-----:|:-----------:|:-------------:|
| Selection sort   | unstable | n<sup>2</sup> | n<sup>2</sup> | n<sup>2</sup> |
| Bubble sort      | stable   | n<sup>2</sup> | n<sup>2</sup> | n             |
| Insertion sort   | stable   | n<sup>2</sup> | n<sup>2</sup> | n             |
| Mergesort        | stable   | n * logn      | n * logn      | n * logn      |
| Quicksort        | unstable | n<sup>2</sup> | n * logn      | n * logn      |
| Radixsort        | stable   | n             | n             | n             |
| Tree sort        | unstable | n * logn      | n * logn      | logn          |
| Heap sort        | stable   | n * logn      | n * logn      | n * logn      |

# Heap

info --> 插入:O(logn) -->  [max/min-heap] --> 取出:O(1) -->  Complete Binary Tree/Balance Binary Tree\
不是實際上去做排序，但是可以滿足取出最大值/最小值 (max-heap/min-heap) 的資料結構 
- 適合用陣列來做，以二元樹呈現是 **平衡樹/完全樹**
- <ins> 保證max/min在 **root** 的位置 </ins>，其他不保證
- 每條從 root 延伸出來的枝 (路徑) 一定是<ins>相對排序過 </ins> 



















